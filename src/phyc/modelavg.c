/*
 *  modelavg.c
 *  PhyC
 *
 *  Created by Mathieu Fourment on 27/6/12.
 *  Copyright (C) 2016 Mathieu Fourment. All rights reserved.
 *
 *  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with this program; if not,
 *  write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>

#include "modelavg.h"
#include "branchmodel.h"
#include "matrix.h"
#include "tree.h"
#include "treeio.h"
#include "math.h"
#include "hashtable.h"
#include "filereader.h"
#include "treestat.h"
#include "treelogio.h"



static int sort_desc_models( const void *a, const void *b ){
	const ModelToAverage *const *aa = a;
	const ModelToAverage *const *bb = b;
	if( (*aa)->weight < (*bb)->weight ) return 1;
	else if( (*aa)->weight == (*bb)->weight ) return 0;
	return -1;
}


#pragma mark -
// MARK: ModelAveraged

ModelAveraged * new_ModelAveraged( int n ){
	ModelAveraged *modelAveraged = (ModelAveraged*)malloc(sizeof(ModelAveraged));
    assert(modelAveraged);
	modelAveraged->n = n;
	modelAveraged->mean = dvector(n);
	modelAveraged->min  = dvector(n);
	modelAveraged->max  = dvector(n);
	return modelAveraged;
}

void free_ModelAveraged( ModelAveraged *ma ){
	free(ma->mean);
	free(ma->min);
	free(ma->max);
	free(ma);
}

#pragma mark -
// MARK: ModelToAverage

ModelToAverage * new_ModelToAverage( const double IC, const int n ){
	ModelToAverage *m = (ModelToAverage*)malloc( sizeof(ModelToAverage) );
    assert(m);
	m->IC = IC;
	m->weight = 0;
	m->params = dvector(n);
	m->n = n;
	return m;
}

void free_ModelToAverage( ModelToAverage *m ) {
	free(m->params);
	free(m);
}

// count: number of models
ModelAveraged * model_averaging( ModelToAverage **models, unsigned nModels, double p ){
    assert(models);
	double minv = models[0]->IC;
	int i = 1;
	
	// Minimum IC
	for ( ; i < nModels; i++) {
		minv = dmin(models[i]->IC, minv);
	}
	
	fprintf(stderr, ". Minimum IC %f\n",minv);
	
	// Relative likelihoods
	double sum = .0;
	for ( i = 0; i < nModels; i++) {
		models[i]->weight = exp( -0.5 * (models[i]->IC - minv) );
		sum += models[i]->weight;
	}
	
	// IC weights
	for ( i = 0; i < nModels; i++) {
		models[i]->weight /= sum;
	}
	
	qsort(models, nModels, sizeof(ModelToAverage*), sort_desc_models);
	
	// Confidence interval
	double cumWeight = 0;
	int p95 = 0;
	while ( cumWeight <= p ) {
		cumWeight += models[p95++]->weight;
	}
	fprintf(stderr, ". IC cutoff %f\n", models[p95-1]->IC);
	fprintf(stderr, ". %d models (%d) included in the %.2f%% confidence interval\n", p95, nModels, (p*100.0));
	
	ModelAveraged *modelAveraged = new_ModelAveraged(models[0]->n);
	
	// Model averaging
	for ( i = 0; i < models[0]->n; i++) {
		double value = 0;
		double value_min = INFINITY;
		double value_max = -INFINITY;
		
		for ( int p = 0; p < p95; p++) {
			double model_value   = models[p]->params[i]   * models[p]->weight / cumWeight;
			value += model_value;			
			value_max = dmax(value_max, models[p]->params[i]);
			value_min = dmin(value_min, models[p]->params[i]);
		}
		
		modelAveraged->mean[i] = value;
		modelAveraged->min[i] = value_min;
		modelAveraged->max[i] = value_max;
		
		// rounding problem
		if ( value > value_max+0.00000001 ){
			//fprintf(stderr, "%s height %f %f %f\n", nodes[i]->name, min_height, height, max_height );
		}
		if ( value < value_min-0.00000001 ){
			//fprintf(stderr, "%s height %f %f %f\n", nodes[i]->name, min_height, height, max_height );
		}
	}	
	
	return modelAveraged;
}



// We should ignore the last trees generated by the GA since it is rejected
Tree * Model_average_from_log( const char *filename, double pp, char ***orderedNames, int start, int end ){
		
	FileReader *reader = new_FileReader(filename,100);
	
	StringBuffer *buffer = new_StringBuffer(100);
	StringBuffer *buffer2 = new_StringBuffer(100);
		
	char *ptr = NULL;
	int count = 0;
	
	int capacity = 100;
	ModelToAverage **models = (ModelToAverage **)calloc( capacity, sizeof(ModelToAverage*) );
    assert(models);
	
	Tree *tree = NULL;
	
	const char *NEXUS_TREE_TRANSLATE_BLOCK = "TRANSLATE";
	char **names = NULL;
	unsigned names_count = 0;
	
	int index = 0;
	
	bool discrete = false;
	
	while ( reader->read_line(reader) ) {
		ptr = reader->line;
		
		if ( String_i_start_with(reader->line, NEXUS_TREE_TRANSLATE_BLOCK, true) ) {
			StringBuffer_empty(buffer);
			names = parseNexusTranslateBlock(reader, buffer, &names_count);
		}
		
		if ( String_start_with(reader->line, "tree", true) ) {
            assert(names);
			if ( index >= start && index <= end ) {
				StringBuffer_empty(buffer);
				
				if( count == capacity-1 ){
					capacity *= 2;
					models = realloc( models, capacity * sizeof(ModelToAverage*) );
				}
				
				if ( String_contains_str(ptr, "class=") ) {
					discrete = true;
				}
				
				//tree TREE1 [&LnL=-4154.174777,IC=8470.349553]]
				if ( String_contains_str(ptr, "IC=") ) {
					ptr += String_index_of_str(ptr, "IC=") + strlen("IC=");
				}
                else if ( String_contains_str(ptr, "AICc=") ) {
					ptr += String_index_of_str(ptr, "AICc=") + strlen("AICc=");
				}
				else {
					error("IC not found in tree\n");
				}
				
				
				while ( isspace(*ptr) ) ptr++;
				while ( (*ptr >= 48 && *ptr <= 57) || *ptr == '.' || *ptr == '-' ) {
					StringBuffer_append_char(buffer, *ptr);
					ptr++;
				}
				
				double IC = atof(buffer->c);
							
				while ( *ptr != '(' ) ptr++;
				char *pch = strrchr(ptr, ';');
				if ( pch != NULL ) {
					ptr[pch-ptr] = '\0';
				}
				else error("missing ; in tree file or spaces at the end\n");
							
				StringBuffer_empty(buffer);
				pch = ptr;
				while ( *pch != '\0' ) {
					// taxa id
					if ( (*pch >= 48 && *pch <= 57) && ( *(pch-1) == '(' || *(pch-1) == ',') ) {
						StringBuffer_empty(buffer2);
						while ( *pch != ':' ) {
							StringBuffer_append_char(buffer2, *pch);
							pch++;
						}
						int index = atoi(buffer2->c);
						//fprintf(stderr, "index %d/%d %s\n", index, names_count, buffer2->c);
						StringBuffer_append_string(buffer, names[index-1]);
						StringBuffer_append_char(buffer, ':');
					}
					else {
						StringBuffer_append_char(buffer, *pch);
					}
					pch++;
				}
				
				Tree *t = new_Tree(buffer->c, NULL, false);
				
				int nNodes = Tree_node_count(t);
				int nParams = Tree_node_count(t)+Tree_node_count(t)+3;// rates, heights, meanRate*3
				
				if ( discrete ) {
					nParams++; // correlation
				}
				
				models[count] = new_ModelToAverage(IC, nParams);
				
				Node **nodes = Tree_get_nodes(t, POSTORDER);
				for ( int i = 0; i < Tree_node_count(t); i++ ) {
					StringBuffer_empty(buffer);
					if ( Node_isroot(nodes[i]) ) {
						
					}
					else {
						int pos = -1;
						if ( (pos = String_index_of_str( nodes[i]->info, "rate=")) != -1 ) {
							pos += strlen("rate=");
							while ( nodes[i]->info[pos] != ',' && nodes[i]->info[pos] != ']' && nodes[i]->info[pos] != '\0' ){
								StringBuffer_append_char(buffer, nodes[i]->info[pos] );
								pos++;
							}
							models[count]->params[i] = atof(buffer->c);
						}
						else error("rate not found");
					}
					models[count]->params[nNodes+i] = Node_height(nodes[i]);
				}
				
				// meanRate
				models[count]->params[nNodes+nNodes]   = TreeStat_mean_rate_scaled(t);
				models[count]->params[nNodes+nNodes+1] = TreeStat_mean_rate_tips_scaled(t);
				models[count]->params[nNodes+nNodes+2] = TreeStat_mean_rate_internal_scaled(t);
				
				// Rate correlation
				if ( discrete ) {
					models[count]->params[nNodes+nNodes+3] = TreeStat_rate_correlation(t);
				}
				
				// keep a tree for the output
				// we should update with parameters of the best tree (time, rates...)
				if ( count == 0 ) {
					tree = t;
				}
				else {			
					free_Tree(t);
				}
							
				count++;
				
			}
			index++;
		}
		else if ( String_contains_str(ptr, "ntax=") ) {
			ptr += String_index_of_str(ptr, "ntax=") + strlen("ntax=");
			while (*ptr >= 48 && *ptr <= 57) {
				StringBuffer_append_char(buffer, *ptr);
				ptr++;
			}
		}
	}

//	if ( names_count != 0 ) {
//		//insertNexusNames2( tree, names );
//		for (int i = 0; i < names_count; i++) {
//			free(names[i]);
//		}
//		free(names);
//	}
//	else {
//		fprintf(stderr, "Could not parse Translate in file\n");
//	}
		
	*orderedNames = names;
	
	
	free_FileReader(reader);
    
    assert(count>0);
    
	ModelAveraged *modelAveraged = model_averaging(models, count, pp );
	
	Node **nodes = Tree_get_nodes(tree, POSTORDER);
    for ( int i = 0; i < Tree_node_count(tree); i++ ) {
        Node_empty_annotation(nodes[i]);
    }
    
	int nNodes = Tree_node_count(tree);
	double ci = pp * 100;
	
	for ( int i = 0; i < Tree_node_count(tree); i++) {
		Node_set_height( nodes[i], modelAveraged->mean[nNodes+i] );
		
		if( !Node_isroot(nodes[i]) ) {
			//StringBuffer_append_format(buffer, "rate=%f,rate_%d%%_CI={%f,%f},", modelAveraged->mean[i], ci, modelAveraged->min[i], modelAveraged->max[i]);
            StringBuffer_empty(buffer);
            StringBuffer_append_format(buffer, "%e", modelAveraged->mean[i]);
            Node_set_annotation(nodes[i], "rate", buffer->c);
            
            StringBuffer_empty(buffer);
            StringBuffer_empty(buffer2);
            StringBuffer_append_format(buffer, "{%e,%e}", modelAveraged->min[i], modelAveraged->max[i]);
            StringBuffer_append_format(buffer2, "rate_%.0f%%_CI", ci);
            Node_set_annotation(nodes[i], buffer2->c, buffer->c);
		}
        
		StringBuffer_empty(buffer);
        StringBuffer_append_format(buffer, "%e", modelAveraged->mean[nNodes+i]);
        Node_set_annotation(nodes[i], "height", buffer->c);
        
        StringBuffer_empty(buffer);
        StringBuffer_empty(buffer2);
        StringBuffer_append_format(buffer, "{%e,%e}", modelAveraged->min[nNodes+i], modelAveraged->max[nNodes+i]);
        StringBuffer_append_format(buffer2, "height_%.0f%%_CI", ci);
        Node_set_annotation(nodes[i], buffer2->c, buffer->c);
        
		//StringBuffer_append_format(buffer, "height=%f,height_%d%%_CI={%f,%f}", modelAveraged->mean[nNodes+i], ci, modelAveraged->min[nNodes+i], modelAveraged->max[nNodes+i]);
		//nodes[i]->info = StringBuffer_tochar(buffer);
	}	
	
	fprintf(stderr, ". Root height %f CI [%f,%f]\n", modelAveraged->mean[nNodes+nNodes-1], modelAveraged->min[nNodes+nNodes-1], modelAveraged->max[nNodes+nNodes-1]);
    
	fprintf(stderr, ". Mean rate (weighted) %f CI [%f,%f]\n", modelAveraged->mean[nNodes+nNodes], modelAveraged->min[nNodes+nNodes], modelAveraged->max[nNodes+nNodes]);
	fprintf(stderr, ". Mean rate tips (weighted) %f CI [%f,%f]\n", modelAveraged->mean[nNodes+nNodes+1], modelAveraged->min[nNodes+nNodes+1], modelAveraged->max[nNodes+nNodes+1]);
	fprintf(stderr, ". Mean rate internal (weighted) %f CI [%f,%f]\n", modelAveraged->mean[nNodes+nNodes+2], modelAveraged->min[nNodes+nNodes+2], modelAveraged->max[nNodes+nNodes+2]);
	
	if ( discrete ) {
		fprintf(stderr, ". Mean correlation coefficient %f CI [%f,%f]\n", modelAveraged->mean[nNodes+nNodes+3], modelAveraged->min[nNodes+nNodes+3], modelAveraged->max[nNodes+nNodes+3]);
	}
	fprintf(stderr, "\n");
	
	free_StringBuffer(buffer);
    free_StringBuffer(buffer2);
	free_ModelAveraged(modelAveraged);
	
	return tree;
	
}


