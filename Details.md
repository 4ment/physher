# Introduction #

Physher is a maximum likelihood-based method for estimating evolutionary rates and divergence times from genetic data. The simplest model assumes that the substitution rate is constant over the whole phylogeny (strict clock model). Alternatively, rate variation among lineages can be taken into account using two different parameterisations: local and discrete clock. Output trees are in nexus format as they contain information such as rates and confidence intervals. These trees should be open with Figtree from this [website](http://tree.bio.ed.ac.uk/software/figtree/).

For more details about the configuration file follow the [link](Inputfile.md)


# Functionalities #

  * Rate heterogeneity among lineages:
    * Local clock: monophyletic lineages evolve at the same rate.
    * Discrete clock: a discrete distribution of rates are assigned to lineages without any restriction on the rate distribution.

  * Search algorithms:
    * Greedy algorithm. (local clock only)
    * Genetic algorithm. (discrete clock only)

  * Substitution models:
    * Nucleotide models: GTR, HKY, K80 and JC69.
    * Codon models: GY94.

  * Rate heterogeneity among sites:
    * Gamma distributed.
    * Proportion of invariant site.

  * Confidence intervals
    * Non-parametric bootstrap (Normal and pertentile) using _bootstrap_ program. (only available for strict clock models)

  * Model averaging of divergence times and substitution rate
    * Using modelavg program. (only available using the genetic algorithm with discrete clocks)

  * Optimization:
    * Model parameters optimized by maximum likelihood are optimized using Brent algorithm.
    * Discrete optimization (allocation of local clocks and discrete rates) are optimized using genetic and greedy algorithms.
    * Likelihood function can use vectorization using SSE.
    * Genetic and greedy algorithms are parallelized with OpenMP.

  * Other programs:
    * _seqotron_: simulate nucleotide data given a fixed tree topology.
    * _modelavg_: model average of trees generated by genetic algorithm with a discrete clock.
    * _bootstrap_: calculate confidence intervals using bootstrap trees generated by a strict clock with physher. Every tree need to have the same topology.

  * Work in progress:
    * Topology search.
    * More substitution models.
    * Faster optimization.
    * Make bootstrapping available for other methods.
    * ...

# Input files #
Physher requires a single configuration file.
For inferring rates and times, the configuration file requires an alignment (FASTA or NEXUS format) and a rooted tree (newick or NEXUS format).

# Outout files #

> Physher will generate several files (starting with the same name) depending on the type analysis selected.

  * output.ratefree.tree: contains maximum likelihood tree without rate. (Branches=expected number of substitution per site)

  * output.strict.tree: contains tree with a strict clock. (Branches=time in unit of time such as year)

  * output.greedy.tree: contains tree with local clocks. (Branches=time in unit of time)

  * output.ga.discrete: contains tree with discrete clock. (Branches=time in unit of time)

  * output.strict.boot.trees: contains bootstrap trees. (Branches=time in unit of time)

  * output.strict.boot.tree: contains MLE tree from the original data set with confidence intervals computed from bootstrap trees.

where 'output' is the output name specified in the config file. (i.e. output.stem=output)


# Real life example #

Unless your computer does not have OpenMP or Pthread libraries installed and SSE are not available, SSE and Pthread/OpenMP versions are strongly recommended.

Using the influenza A data set ([available here](https://drive.google.com/folderview?id=0B1fZePvFRVeBemNjUE4zZWdPVVU&usp=sharing/fluA.zip))

`./physher fluA-localclock.config`

In this examle, physher uses the greedy algorithm with the local clock model. It will generate the first 3 files specified in the previous section.


# Other programs #
Details are available when programs are run without any options or with the option -h (e.g. ./bootstrap)
  * bootstrap: calculate confidence intervals of rates and times from a set of trees generated by Phsyher.
  * simultron: simulate nucleotide data sets.
  * modelavg: model averaging of models generated by a genetic algorithm.

Note: These programs are not vectorised nor parallelised.

<a href='Hidden comment: 
http://chart.apis.google.com/chart?cht=bhs&chd=t:86,68,62,59,55,51&chs=300x200&chxl=0:|0wins|25wins|50wins|75wins|100wins|1:|Rickoos|Reefer|MekaDragon|spoonbeast|Aliboy|pb&chxt=x,y&nonsense=something_that_ends_with.png
'></a>

# Quick and dirty benchmark #
Running time in minutes against the number of threads (1-10) using different combinations of compilers (GCC4.7 or Clang 5.0), vectorisation (SSE), and parallelisation (Pthread or OpenMP) algorithms.


![http://chart.apis.google.com/chart?cht=lc&chds=0,80&chs=500x300&chd=t:78.93,40.3,28.5,22.11,18.76,17.85,16.93,16.4,15.7,15.23|39.48,20.3,14.2,11.13,9.45,8.91,8.81,8.8,8.88,9.21|49.48,25.5,17.85,13.96,11.71,10.96,10.43,10.06,9.95,10.06|43.0,22.3,15.48,12.13,10.1,9.66,9.31,9.2,9.25,9.48|43.1,22.85,17.28,14.78,12.81,12.16,12.18,11.36,11.63,11.86&chdl=Pthread+clang5.0|SSE+Pthread+clang5.0|Pthread+GCC4.7|SSE+Pthread+GCC4.7|SSE+OpenMP+GCC4.7&chxt=x,y&chtt=Performance+on+Mac+Pro+3.33GHz+6-Core&chxr=0,1,10|1,0,80&chm=o,E69FF8,0,-1,5|o,FF0000,1,-1,5|o,00FF00,2,-1,5|o,0000FF,3,-1,5|o,000000,4,-1,5&chco=E69FF8,FF0000,00FF00,0000FF,000000&nonsense=graph.png](http://chart.apis.google.com/chart?cht=lc&chds=0,80&chs=500x300&chd=t:78.93,40.3,28.5,22.11,18.76,17.85,16.93,16.4,15.7,15.23|39.48,20.3,14.2,11.13,9.45,8.91,8.81,8.8,8.88,9.21|49.48,25.5,17.85,13.96,11.71,10.96,10.43,10.06,9.95,10.06|43.0,22.3,15.48,12.13,10.1,9.66,9.31,9.2,9.25,9.48|43.1,22.85,17.28,14.78,12.81,12.16,12.18,11.36,11.63,11.86&chdl=Pthread+clang5.0|SSE+Pthread+clang5.0|Pthread+GCC4.7|SSE+Pthread+GCC4.7|SSE+OpenMP+GCC4.7&chxt=x,y&chtt=Performance+on+Mac+Pro+3.33GHz+6-Core&chxr=0,1,10|1,0,80&chm=o,E69FF8,0,-1,5|o,FF0000,1,-1,5|o,00FF00,2,-1,5|o,0000FF,3,-1,5|o,000000,4,-1,5&chco=E69FF8,FF0000,00FF00,0000FF,000000&nonsense=graph.png)